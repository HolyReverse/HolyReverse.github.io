<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>KnightCTF - Knight Switch bank </title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
	background-color:rgb(55, 53, 47);
	color: white;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		background-color:rgb(55, 53, 47);
		color: white;
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid white;
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;

}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="d93bca6f-8d8d-4794-8f19-62e8fe10262f" class="page sans"><header><h1 class="page-title">KnightCTF - Knight Switch bank </h1></header><div class="page-body"><p id="9193ef02-b215-4f1a-807a-81eccff19960" class="">
</p><table id="d7425858-b507-48c4-abbe-31bb63392eff" class="simple-table"><tbody><tr id="0003b468-9d34-454f-9f70-c106eb78fca3"><td id="rfFO">Nom</td><td id="u^@;">Knight Switch Bank</td></tr><tr id="05e0d23c-565e-4e89-b3a3-c617c2f5d1a9"><td id="rfFO">Points</td><td id="u^@;">200</td></tr><tr id="a4a07975-a82d-496c-bc0a-973b85698828"><td id="rfFO">Difficult√© </td><td id="u^@;">Facile</td></tr><tr id="22a56a47-eb91-4bb8-ac49-7ad69a033224"><td id="rfFO">Validation</td><td id="u^@;">173</td></tr></tbody></table><p id="d0bce5e9-53fc-4faf-863b-3f5f0b92e07e" class="">Bonjour, je vous pr√©sente aujourd‚Äôhui ma writeup sur le challenge de Reverse Knight Switch bank du CTF KnightCTF.</p><p id="1ab2eead-7315-42a5-8e88-0f8c9eb79ba2" class="">
</p><p id="385b1f34-3202-4267-b4d9-c7bd74a9ca7d" class="">Commen√ßons par le commencement, tout d‚Äôabord lan√ßons le binaire.</p><figure id="925d96a4-f750-4cb5-a23f-cb0d7a2d40c0" class="image"><a href="images/Untitled.png"><img style="width:978px" src="images/Untitled.png"/></a></figure><p id="cd95882b-f022-4732-a169-23e614e58184" class="">
</p><h2 id="b8af4a8c-840f-4663-a0b3-7d6f999ac5a6" class="">Analyse et compr√©hensions du binaire</h2><p id="491c0d0a-558b-46a5-8906-db22f87e077d" class="">Lorsque nous lan√ßons le binaire on peut voir qu‚Äôil demande un mot de passe. On peut potentiellement en conclure que le mot de passe est en dur dans le code du binaire, mais qu‚Äôil y a un algorithme √† reverse. C‚Äôest partit r√©cup√©rons le pseudo code.</p><p id="5b67a89a-4055-47eb-8524-01b541042018" class="">
</p><table id="694acde4-79b6-4f2b-b863-a79c3838b5b6" class="simple-table"><tbody><tr id="88c7e638-9cd0-4c25-8743-702d8d225e7c"><td id="]SSG">Fonctions du binaire</td></tr><tr id="9ef222b5-b441-48ed-8235-9db6fcf96197"><td id="]SSG">main</td></tr><tr id="11e4c95d-48a2-4c57-899c-dd681e70b765"><td id="]SSG">winner</td></tr></tbody></table><p id="074877ed-a02d-4f65-ae47-5c275d5ba107" class="">
</p><p id="f626d0b6-dd8d-4cf3-821b-41e306689ca2" class="">En effet on peut obs√©rver qu‚Äôil existe seulement deux fonctions dans le binaire. En allant voir dans le winner j‚Äôai vu que cela affichait simplement une chaine de caract√®re m‚Äôindiquant que le mot de passe rentr√© √©tait correct. Nous allons donc analyser la fonction main.</p><p id="c7416b37-db74-4ece-b164-b260a6e11df8" class="">
</p><p id="037b3545-5d6a-48fe-9975-98f83e9a8170" class="">Main: </p><pre id="d35013ba-5cea-4f3e-a269-39fd14d4b10b" class="code"><code>undefined8 main(void)
{
    int64_t var_430h;
    int64_t var_230h;
    int64_t var_30h;
    int64_t var_28h;
    int64_t var_20h;
    int64_t var_18h;
    int32_t var_10h;
    char var_9h;
    int32_t var_8h;
    int64_t var_4h;
    
    var_30h = 0x4164485d5549525a;
    var_28h = 0x41494447414a644e;
    var_20h = 0x4173444476414978;
    var_18h._0_4_ = 0x71444479;
    var_18h._4_2_ = 0x5f;
    var_4h._0_4_ = 0;
    var_8h = 0;
    puts(0x402008);
    puts(&quot;\tKnight Switch Bank&quot;);
    puts(0x402048);
    puts(&quot;Welcome to Knight Switch Bank....&quot;);
    printf(&quot;Please enter your password : &quot;);
    __isoc99_scanf(0x402130, &amp;var_230h);
    for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }
    for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
        *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
    }
    var_9h = &#x27;\0&#x27;;
    var_10h = 0;
    do {
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) == &#x27;\0&#x27;) {
code_r0x00401437:
            if (var_9h == &#x27;\0&#x27;) {
                puts(&quot;Oh My God ! You entered a wrong password.&quot;);
            } else {
                winner();
            }
            return 0;
        }
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) != *(char *)((int64_t)&amp;var_430h + (int64_t)var_10h)) {
            var_9h = &#x27;\0&#x27;;
            goto code_r0x00401437;
        }
        var_9h = &#x27;\x01&#x27;;
        var_10h = var_10h + 1;
    } while( true );
}</code></pre><p id="f552cc92-a587-441b-bd84-36db9907a65c" class="">
</p><p id="534bb1fa-2605-41dc-90cc-2a9e8c59c198" class="">Voil√† donc le contenu de notre fonction main. Je vous propose d‚Äôanalyser le code √©tape par √©tape.</p><p id="61b5fb4f-edc8-4a0c-a490-83f4e78a8ea7" class="">
</p><p id="efa76654-2d2d-4bd2-8edf-e07de469097b" class="">Je vais vous √©pargner les d√©clarations de variables ce serait inutile allons directement √† l‚Äôessentiel.</p><p id="2247f316-4d42-4c28-8f43-f1e4736bb364" class="">
</p><h3 id="2daaf3fd-e698-46f8-a418-c963be0f0b98" class="">1 √®re √©tape de l‚Äôalgorithme</h3><pre id="d25e5684-f76e-40ee-942b-32e0d7287ce4" class="code"><code>		var_30h = 0x4164485d5549525a;
    var_28h = 0x41494447414a644e;
    var_20h = 0x4173444476414978;
    var_18h._0_4_ = 0x71444479;
    var_18h._4_2_ = 0x5f;
    var_4h._0_4_ = 0;
    var_8h = 0;
    puts(0x402008);
    puts(&quot;\tKnight Switch Bank&quot;);
    puts(0x402048);
    puts(&quot;Welcome to Knight Switch Bank....&quot;);
    printf(&quot;Please enter your password : &quot;);
    __isoc99_scanf(0x402130, &amp;var_230h);
    for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="fb1239df-d5cb-4c6c-bc3f-09558815fadd" class="">
</p><p id="3d32cc72-6df3-4cd7-920a-c9300438d73c" class="">Comme vous pouvez le voir il y a tout d‚Äôabord des initialisation de variable on peut donc en conclure assez facilement que ce sont potentiellement les chaines correspondant au flag.</p><p id="6d4375f4-08e5-4afe-9908-1061c8f5db0d" class="">Mais nous verrons √† la fin si c‚Äôest bien cela.</p><p id="f15b6a12-4292-419f-9978-28d956764677" class="">
</p><p id="03971c40-7e0f-49d1-b291-9d37f76673c9" class="">Ensuite si on lit bien le code on voit qu‚Äôil fait un simple scanf il va simplement mettre le contenu que l‚Äôon √©crit dans le STDIN dans le buffer.</p><p id="eaa99e6d-8b1f-4f06-a3ac-92e087ba38f2" class="">
</p><pre id="52530879-a77e-41be-bccb-37f9b461202c" class="code"><code>for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="21b034b2-701c-4cff-b6f9-075a75be65a8" class="">
</p><p id="4cf4ca67-e5a4-46c9-b845-a9b0fe3a42cf" class="">En effet rappelez vous notre variable du buffer s‚Äôappelle var_230h. Le code ci-dessus est plutot simple nous allons simplement parcourirs la chaine rentr√© dans le scanf. D‚Äôou la boucle for dans cette boucle il va y avoir des actions tr√®s int√©ressante. Alors √©coutez bien.</p><p id="b2887d68-148a-44ce-97d2-0a24ceba9933" class="">
</p><p id="f74c7302-4499-45f4-ab65-7016f270e6e7" class="">Tout d‚Äôabord la premi√®re v√©rification est super simple il va regarder si la valeur de notre caract√®re n‚Äôest pas comprise entre ‚ÄòA‚Äô et ‚ÄòM‚Äô si ce n‚Äôest pas le cas et bien il va prendre une variable qu‚Äôil aura initialis√© juste avant la boucle et il y inserera la somme de notre caract√®re + ‚Äò\r‚Äô</p><p id="4297a98c-97fe-412a-8fef-9eca6c86b772" class="">
</p><pre id="88f9a50a-e735-417f-83c3-ca44cac4e62b" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;</code></pre><p id="3f4e66ff-7fe6-4c78-907c-9cdf2a0d48f9" class="">
</p><pre id="c4887ba7-e25f-43cc-a54d-cdf5a2ceea1a" class="code"><code>input = &#x27;K&#x27; // K est bien dans l&#x27;interval de A et M donc il rentrera dans le else

result = ord(input)+ord(&#x27;\r&#x27;) // soit 75+13
//=&gt; 88</code></pre><p id="fbee7d58-35d5-4473-b548-284096e143bd" class="">
</p><p id="21cb5a29-1a77-4939-a788-01c28efa2707" class="">Donc voil√† √ßa c‚Äôest l‚Äôop√©ration qui ce passera seulement si le caract√®re est compris entre ‚ÄòA‚Äô et ‚ÄòM‚Äô</p><p id="34581d12-c073-4bd3-a168-1b23110d3bde" class="">
</p><p id="2e339f64-5818-40f9-a00e-793e31cc37b4" class="">En revanche si celui-ci n‚Äôest pas contenu entre les deux l‚Äôalgorithme va rentrer dans une autre condition qui v√©rifie si idem la lettre n‚Äôest pas contenu entre ‚Äòa‚Äô et ‚Äòm‚Äô si tel est le cas il refait la m√™me op√©ration que pour le premier.</p><p id="ccf6268c-2ea8-439d-9338-3327f6ff88f0" class="">
</p><p id="6dc018ab-7005-4566-828d-d0284a08ac25" class="">Si du coup le caract√®re n‚Äôest pas compris entre ‚Äòa‚Äô et ‚Äòm‚Äô il rentre dans une condition verifiant si le caract√®re n‚Äôest pas compris entre ‚ÄòN‚Äô et ‚ÄòZ‚Äô si le caract√®re en question est compris entre ‚ÄòN‚Äô et ‚ÄòZ‚Äô nous rentrons dans le else.</p><p id="156b3e34-119d-4d7e-8354-b21171f6b416" class="">
</p><pre id="6a222ea9-c4a9-4a51-9d61-d0fc0b841aa3" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
              *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
             </code></pre><p id="3d511e26-3737-4de7-b545-16fec18f56e9" class="">
</p><p id="8633aeb0-a08b-4b02-9b35-9632ecb9c3bd" class="">Rien de bien compliquer, il prend le caract√®re actuel et il le soustrait √† 0xd.</p><p id="99fedef3-885f-415b-8a8c-bf5c0c117f15" class="">Petit exemple en pseudo code.</p><p id="53596dac-60c3-4563-b7ca-51fe5d75bf2f" class="">
</p><pre id="f9f5aec5-95f5-445f-88e5-9be878aafc08" class="code"><code>input = &#x27;X&#x27;
result = ord(input)-0xd // soit 88-0xd ou 88-1
//=&gt; 75</code></pre><p id="b6f87cff-caf5-410c-92df-c0ce4fbe5356" class="">
</p><p id="2fc61c22-877b-46a7-99f0-e76e6742cd08" class="">Et il fait √©galement la m√™me proc√©dure pour les minuscule. Maintenant si toute ces conditions sont correctes. Il soustrait 0x20 au carac√®re actuel, c‚Äôest dans le cas ou y a des caract√®res sp√©ciaux.</p><p id="1d8cebcd-899f-4cd4-883b-b40bc3a0cadb" class="">
</p><pre id="af82b9ad-002e-41bf-aaab-d466979015ff" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;</code></pre><p id="d2824dc4-395b-4e0c-acfe-48a799fa6440" class="">
</p><pre id="ffe67e97-2bf9-4015-a1b0-eee5e9084325" class="code"><code>input = &#x27;{&#x27;

result = ord(input)-0x20 // soit 123-0x20
//=&gt; 91</code></pre><p id="b22796b0-3805-4349-8b30-01f415e76f2a" class="">
</p><p id="51306af4-bebc-4776-940e-55b31072edab" class="">Parfait nous avons donc r√©ussi √† comprendre la premi√®re √©tape de l‚Äôalgorithme.</p><h3 id="998e19f2-7081-4e85-93ad-d1079b2969ad" class="">2 √®me √©tape de l‚Äôalgorithme</h3><p id="90b7b32f-c4b2-4a58-b7bf-3b5df52e6038" class="">La deuxi√®me √©tape est la plus simple de toute car elle ne comporte que tr√®s peu de code.</p><p id="297cfa16-b859-4967-b687-a44cd0edb989" class="">
</p><pre id="965dd14d-57fa-4b36-8b73-5e006afbd0c2" class="code"><code>for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
    *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = 
							*(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
}</code></pre><p id="fe47f6b6-d987-4b60-924f-cede2b0642a1" class="">
</p><p id="5d6c89be-a25f-4f77-9bf2-8ec4eeadc86b" class="">Le code est tr√®s simple il va simplement parcourir toute la chaine de caract√®re que l‚Äôon a instanci√© juste avant dans la 1√®re √©tape, il va ensuite simplement remplacer chaque caract√®re par le caract√®re actuel+ 2</p><p id="c425e87a-98ba-4cd4-a454-fd268aed1289" class="">
</p><pre id="1938932a-9243-4e46-9b48-ac95d1ef6ab7" class="code"><code>input = &#x27;A&#x27;

res = ord(input)+0x2 // 65+0x20
//=&gt; 67</code></pre><p id="6426dcd4-321a-43e2-bf06-bc6dea85f5af" class="">
</p><p id="88a02531-3c81-4de6-b531-0d94ac8d3278" class="">Y a rien de plus √† dire sur cette √©tape c‚Äôest tout ce qu‚Äôelle fait üôÇ.</p><p id="4736330e-6b5d-4ff8-9e9b-520492c40292" class="">
</p><h3 id="03071dab-2dbe-4286-8f73-0705b2b9334b" class="">3 √®me √©tape de l‚Äôalgorithme</h3><p id="531b2cc1-66ef-4fd7-a9a2-f1163ec81190" class="">Bon nous allons essayer de comprendre la 3 √®me et derni√®re √©tape de l‚Äôalgorithme. Elle est toute simple car ce n‚Äôest que la partie qui verifie si le flag est bon ou mauvais.</p><p id="2286de14-7e2b-4d78-98a5-34e3b6aef821" class="">
</p><pre id="924fa1a4-3e44-4bde-8ca5-377a0f43f5f8" class="code"><code>var_9h = &#x27;\0&#x27;;
    var_10h = 0;
    do {
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) == &#x27;\0&#x27;) {
code_r0x00401437:
            if (var_9h == &#x27;\0&#x27;) {
                puts(&quot;Oh My God ! You entered a wrong password.&quot;);
            } else {
                winner();
            }
            return 0;
        }
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) != *(char *)((int64_t)&amp;var_430h + (int64_t)var_10h)) {
            var_9h = &#x27;\0&#x27;;
            goto code_r0x00401437;
        }
        var_9h = &#x27;\x01&#x27;;
        var_10h = var_10h + 1;
    } while( true );</code></pre><p id="358da731-a0a2-4e82-8861-f41d662145fe" class="">
</p><p id="9202941c-affc-487c-a8df-b12a026f8941" class="">Je ne vais pas trop m‚Äôattarder car le code est relativement compr√©hensible. Mais en gros on va it√©rer sur la chaine qui stock une des parties du flag.</p><p id="58e157d7-132e-486a-9c5e-188676d4cfc1" class="">
</p><p id="97d59c2b-b39d-41e8-ba23-57aabf307e09" class="">Celle-ci:</p><pre id="acce3fdb-2e83-4fab-af3f-83a62dac8556" class="code"><code>var_30h = 0x4164485d5549525a;</code></pre><p id="e84f79c5-181e-4df8-89e8-525053d97dc4" class="">
</p><p id="bab4010c-4fd8-492d-a444-8a536513e02b" class="">Puis √† la fin on verifie sur le caract√®re actuel du flag est √©gal au caract√®re actuel de notre buffer. C‚Äôest maintenant qu‚Äôon peut en conclure que var_30h et le reste stock bien notre flag. Notre mission si on l‚Äôaccepte est de reverse l‚Äôalgorithme.</p><p id="7f06a92e-f8d4-49f8-bfe2-31dcc4d43894" class="">
</p><h2 id="04abda09-3983-44df-b0bb-ab7fc3c6da6a" class="">Reverse l‚Äôalgorithme</h2><p id="74713deb-0695-4b89-9f78-d0e9ee13804d" class="">
</p><p id="96f50438-00b5-4c31-bbcb-f26b95312b8c" class="">Ce qui est important dans cet algorithme c‚Äôest que l‚Äôon va devoir vraiment faire les √©tapes au sens inverse. C‚Äôest √† dire que nous allons d‚Äôabord devoir reverse la 2 √®me step et ensuite la 1 √®re pour avoir la chaine final.</p><p id="62db2a43-1587-425f-8a29-aeccd0c51f49" class="">Avant tout on sait que notre debut de flag sera forc√©ment KCTF{. On a donc d√©j√† un petit indice pour l‚Äôexploitation.</p><p id="125f7eb9-4eea-420d-b0d8-a4680858e860" class="">
</p><p id="c75364a2-3197-4f77-9b1b-0051f286d777" class="">Commen√ßons par prendre le dernier byte de var_30h √©tant donn√© que c‚Äôest cens√© √™tre le ‚ÄòK‚Äô on va facilement pouvoir comprendre comment reverse.</p><p id="fbcc0a11-7f90-4902-9d39-e3c15499842d" class="">
</p><p id="3a91de94-a164-4589-a765-c3c48c33021b" class="">flag:</p><pre id="d49b8a5d-a365-4304-bec6-90267c27a8e4" class="code"><code>var_30h = 0x4164485d5549525a;</code></pre><p id="9b175577-f4b3-4f85-9c72-ac5b56119ccc" class="">Donc reprenons notre step 2</p><pre id="ded2ed3f-2e0c-4357-8980-adc74b6f7efa" class="code"><code>for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
    *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = 
							*(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
}</code></pre><p id="3a5e47e4-22de-45a9-bb15-69c17458ef5f" class="">Rappelez vous notre step 2 prend chaque caract√®re de la chaine final et lui ajoute 2. Il n‚Äôy a pas besoin d‚Äôun doctorat en math√©matique pour comprendre que pour reverse cette step nous allons simplement devoir soustraire 2 √† notre byte.</p><p id="342ac684-7b1e-46f7-a9dc-8a1bf60f574a" class="">
</p><pre id="6f132013-190c-4ef6-94e2-7b56383a6e5d" class="code"><code>byte = 0x5a

print((byte-0x2))
#=&gt;88 soit =&gt; &#x27;X&#x27;</code></pre><p id="aa9fe122-b2ea-4945-88f8-afad9d50487d" class="">
</p><p id="bc977dcf-4420-4203-9d6c-df4201bb7c36" class="">Parfait nous avons reverse la 2 √®me step √† pr√©sent il va falloir simplement que je reverse la 1 √®re step c‚Äôest partit.</p><p id="02d4a82d-f536-4d80-9ee4-9995ba56989e" class="">
</p><pre id="8ea16750-b537-46ed-9460-e3054be5a02b" class="code"><code>for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="a43d62f9-6b7a-4fa2-83d6-ebd0d41c875e" class="">
</p><p id="b27513a7-ea12-41e4-8c67-42a9c4eafad0" class="">Donc ce que nous savons de cette partie c‚Äôest que si l‚Äôon met une lettre majuscule ou minuscule compris entre ‚Äòa‚Äô et ‚Äòm‚Äô et bien nous rentrons dans le else.</p><p id="e385a93d-15f5-4cdd-a8a3-eac2155226ba" class="">On sait que notre premier caract√®re est forc√©ment ‚ÄòK‚Äô</p><p id="0fe890e2-2daa-4a95-94b0-5bd70b14aac8" class="">
</p><p id="427fdcfe-ff0f-4d7c-aab4-fe41be067a6b" class="">Alors brutefor√ßons voir le quel √† la fin obtiendra une lettre coh√©rente.</p><p id="b8345155-d7b8-49da-8191-a22bb67cde9a" class="">
</p><pre id="184b4785-d8b8-47e5-b556-debb807b7ac7" class="code"><code>byte = 0x5a

print((byte-0x2)-13) # on soustrait √† notre byte revers√© 13 car 13 √©quivaut √† la valeur
# ascii de &#x27;\r&#x27;
#=&gt; 75 soit &#x27;K&#x27;</code></pre><p id="cde6ab6b-42ec-45f3-8c1a-f194715e883a" class="">
</p><p id="209944fc-d32f-4249-9251-9db257b63340" class="">√† pr√©sent je vous propose donc de scripter tout cela.</p><p id="b882d2dd-c4fb-40f0-bf54-764e7739ce7d" class="">
</p><h3 id="51a593a4-124a-4d27-9870-e7400c8fe542" class="">Conception d‚Äôun script permettant de reverse l‚Äôalgorithme</h3><p id="5ba58f20-6f32-4486-92dc-262707ee6ec4" class="">
</p><p id="271fe01c-bb2e-4a96-b8c4-57b81c5f4947" class="">Donc en effet nous avons compris comment reverse les lettres entre ‚ÄòA‚Äô et ‚ÄòM‚Äô ou a et ‚Äòm‚Äô</p><p id="2b74e793-1c24-4f7a-9a35-93fd45c6bd64" class="">
</p><p id="efff56e9-16a5-4a58-97c5-860e8451e3e5" class="">Le probl√®me est : ‚ÄúComment je vais savoir quel algorithme appliquer √† ma lettre sans savoir √† l‚Äôavance son range ?‚Äù. Rien de plus simple ce que j‚Äôai fais c‚Äôest simplement de bruteforce.</p><p id="213e27cf-42c2-433d-9734-6ab663a14982" class="">
</p><p id="d19798a6-462a-4f31-87a4-3ca928c8a4b3" class="">Voici un petit exemple:</p><pre id="c148d147-b941-410a-a5e0-de13ddbb3262" class="code"><code>def step2(byte)
		return byte-0x2
end

def algo_range_a_m(byte)
		return (step2(byte)-13)
end

def algo_range_n_z(byte)
		return (step2(byte)+0xd)
end


def step1(byte)
		algo_operation1 = algo_range_a_m(byte)
		algo_operation2 = algo_range_n_z(byte)
		algo_operation3 = (step2(byte)+0x20)
	
		if (algo_operation1 &gt;= &#x27;A&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;M&#x27;.ord) ||(algo_operation1 &gt;= &#x27;a&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;m&#x27;.ord)
        return algo_operation1.chr
    elsif (algo_operation2 &gt;= &#x27;N&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;Z&#x27;.ord) || (algo_operation2 &gt;= &#x27;n&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;z&#x27;.ord)
        return algo_operation2.chr
    else
        return algo_operation3.chr
    end
end</code></pre><p id="9528c628-c3ac-4495-9dfc-a30a99ab5043" class="">
</p><p id="d53e6f0f-fef1-474f-bdd6-df0635286f1b" class="">Donc pour la petite explication je vais simplement appliquer chaque algorithme √† chaque caract√®re et comparer en gros si par exemple le r√©sultat est dans les ranges si tel est le cas on renvois la valeur correspondant au range.</p><p id="095d9117-fd5d-47e9-bf24-1f2cbb1255c4" class="">
</p><p id="49b16326-c785-4fa9-b3e4-4f2af6ccc4a8" class="">Voici le script de fin qui reverse nos chaines de caract√®res. ;)</p><p id="363f91b7-aeb2-4781-af86-54cd6839b93f" class="">
</p><pre id="1874e548-23c1-4b5b-a293-2a247ee2b1d2" class="code"><code>def step2(byte)
    return byte-0x2
end

def algo_range_a_m(byte)
    return (step2(byte)-13)
end

def algo_range_n_z(byte)
    return (step2(byte)+0xd)
end


def step1(byte)
    algo_operation1 = algo_range_a_m(byte)
    algo_operation2 = algo_range_n_z(byte)
    algo_operation3 = (step2(byte)+0x20)

    if (algo_operation1 &gt;= &#x27;A&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;M&#x27;.ord) ||(algo_operation1 &gt;= &#x27;a&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;m&#x27;.ord)
        return algo_operation1.chr
    elsif (algo_operation2 &gt;= &#x27;N&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;Z&#x27;.ord) || (algo_operation2 &gt;= &#x27;n&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;z&#x27;.ord)
        return algo_operation2.chr
    else
        return algo_operation3.chr
    end
end

def main()
    text0 = [0x41,0x64,0x48,0x5d,0x55,0x49,0x52,0x5a].reverse
    text1 = [0x41,0x49,0x44,0x47,0x41,0x4a,0x64,0x4e].reverse
    text2 = [0x41,0x73,0x44,0x44,0x76,0x41,0x49,0x78].reverse
    text3 = [0x71,0x44,0x44,0x79].reverse

    flag = []
    4.times do |i|
        tmp_flag = []

        eval(&quot;text#{i}&quot;).map.with_index do |byte, j|
            tmp_flag[j] = step1(byte)
        end

        flag[i] = tmp_flag
    end

    puts &quot;Flag: #{flag.join}}&quot;
end

if __FILE__ == $0
    main()
end</code></pre><p id="9d9e2693-fcc2-4e10-9eb4-7a01ca0634a9" class=""> </p><pre id="c509e56f-c382-447e-b2de-25a8940f6655" class="code"><code>Flag: KCTF{So_YoU_ROT_iT_gOOd_jOOb}</code></pre><p id="0beb6ff0-6e7c-4f43-b4d0-b2e78080bc26" class="">
</p><p id="7af6669e-ef63-4797-80f3-72abacfa80fd" class="">Sur ce je vous souhaite une bonne journ√©e üôÇ</p></div></article></body></html>
